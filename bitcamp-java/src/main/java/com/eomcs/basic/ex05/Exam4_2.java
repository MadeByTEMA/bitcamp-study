// 비트 이동 연산자 : >>, >>>, << 
package com.eomcs.basic.ex05;

public class Exam4_2 {
    public static void main(String[] args) {
        // >> 비트 이동 연산자 사용법
        // - 왼쪽 쪽 빈자리 : 원래 숫자와 같은 부호 값으로 채운다.
        // - 양수라면 0, 음수라면 1을 채운다.
        // 오른쪽 경계를 넘어간 비트 : 짜른다.
      
        int i = 0b01101001; // 105
        System.out.println(i); 
        // 00000000 00000000 00000000 01101001

        
        System.out.println(i >> 1);
        // x00000000 00000000 00000000 0110100|1
        // 000000000 00000000 00000000 0110100    => 52
        
        System.out.println(i >> 2);
        // x00000000 00000000 00000000 0011010|01
        // 000000000 00000000 00000000 0011010    => 26 
        
        System.out.println(i >> 3);
        // x00000000 00000000 00000000 0001101|001
        // 000000000 00000000 00000000 0001101    => 13
        
        System.out.println(i >> 4);
        // x00000000 00000000 00000000 0000110|1001
        // 000000000 00000000 00000000 0000110    => 6
        

        // 음수일 경우,
        // 

        i = 0b11111111_11111111_11111111_10101001; // -87
        
        System.out.println(i); 
        System.out.println(i >> 1); 
        // 1_11111111_11111111_11111111_1010100|1   => -44 

        System.out.println(i >> 2); 
        // 11_11111111_11111111_11111111_101010|01 => -22

        System.out.println(i >> 3); 
        // 111_11111111_11111111_11111111_10101|001 => -11
        
        System.out.println(i >> 4);
        // 1111_11111111_11111111_11111111_1010|1001 => -6
    }
}

// 오른쪽 이동
// - 1비트 이동은 나누기 2 한 것과 같은 효과를 준다.
// - 소수점 이하는 짤리는 효과를 갖는다.
//   실무에서는 나눗셈 연산이 비용(시간과 CPU 사용량)이 많이 들기 때문에 
//   소수점 이하까지 
// 